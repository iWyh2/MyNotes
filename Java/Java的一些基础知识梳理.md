# Java的一些基础知识梳理

## 1. Java的特性

* 面向对象
* 健壮性（强类型，异常处理，垃圾的自动收集）
* 跨平台性
* 解释型语言（编译后的代码不能直接被机器执行）



## 2. Java的流程控制

在进行程序设计的时候，我们会经常进行逻辑判断，根据不同的结果做不同的事，或者重复做某件事，我们对类似这样的工作称为流程控制。在Java中，流程控制分为两大类：**选择**和**循环**。



## 3. Java的数组

C/C++风格

```c++
声明数组变量：dataType arrayRefVar[]; 
```

Java也有这样的写法，但不推荐。

* Java风格：

```java
声明数组变量：dataType[] arrayRefVar;
创建数组：arrayRefVar = new dataType[arraySize]
```



## 4. Java的自动类型转换

* 精度小的给精度大的

* byte -> short -> int -> long -> float -> double

​              				char↑



## 5. Java的表达式类型提升

* 表达式中，小范围型的变量会自动转换成当前较大范围的类型再运算

* byte short char -> int -> long -> float -> double
* 表达式的最终结果类型由表达式中的最高类型决定
* 表达式中，byte short char 直接转换成int进行运算



## 6. Java的强制类型转换

* 强行将类型范围大的赋值给类型范围小的
* 会造成数据丢失或溢出
* 浮点型强转整型会丢失小数部分，只保留整数部分



## 7. Java的static关键字

* 静态方法只能访问静态的成员
* 实例方法可以访问静态的也可以访问实例的成员
* 静态方法中不可以有this
* 饿汉单例设计模式（已经存在了）
* 懒汉单例设计模式（需要时再创建）



## 8. Java的代码块

* 是Java类的五大成分之一
* 定义在类中，方法之外
* 静态代码块（static{}）：随着类的加载而加载，自动触发，只执行一次，用于初始化静态数据便于后续使用
* 构造代码块（{}）：在每次创建对象实例化类时，在调用构造器之前先调用这个代码块，用于初始化实例资源



## 9. Java的final关键字

* 修饰类：为最终类，不能被继承
* 修饰方法：为最终方法，不能被重写
* 修饰变量：为常量，不能被修改
  * 修饰基本类型变量：变量存储的数据值不能改变
  * 修饰引用类型变量：变量存储的地址值（对象）不能改变，但地址指向的对象内容可以改变



## 10. Java的常量

* 由**public static final**修饰的成员变量
* 必须要有初始化值
* 执行时其值无法改变
* 执行原理：编译阶段进行”宏替换“，常量替换为真实字面量
* 命名规范：全部大写
* 用于做系统的配置信息，提高可读性



## 11. Java的枚举

* 是Java的特殊类

* ```java
  格式：
  修饰符 enum 枚举名称 {
  	第一行罗列枚举类实例名称;
  }
  ```

* 最终类，不能被继承

* 不能创建对象

* 相当于多例模式

* 用于信息标志与分类



## 12. Java的封装

* 用于正确设计对象的属性和方法
* 原则：对象代表什么，就要封装对应的数据，并提供对应的行为



## 13. Java的继承

* ```java
  格式：
  public class 子类名 extends 父类名 {}
  ```

* 子类继承了父类，可以直接使用父类的公共属性与方法。能继承父类的私有成员，但无法直接使用。不会继承父类的静态成员，这是共享。

* 不会继承父类的构造器

* 单继承，只继承一个父类

* Java不支持多继承，支持多层继承

* 所有类都是Object的子类（默认的）

* 在子类方法中访问成员，为就近原则，从自己开始往上级寻找

* super指向父类，this指向本类

* 子类有与父类一样的方法声明则就是重写了父类的该方法，可加@Override校验

* 父类的私有方法与静态方法不能被重写

* 子类继承父类后，创建对象时，**先默认访问父类的的无参构造器，再访问自己的构造器**，因为要先完成父类的数据空间的初始化，所以**子类的构造器默认第一行不写也存在super()**

* 可以调用父类的有参构造器，用于初始化继承自父类的数据

* 父类必须要有无参构造器，不然子类构造器默认访问父类无参构造器会报错，除非手动调用父类有参构造器

* this可以调用本类其它构造器，在构造器中this(..)不能与super(..)一起存在



## 14. Java的抽象类

* ```java
  格式：
  修饰符 abstract class 类名{
  	修饰符 abstract 返回值类型 方法名称(形参列表);
  }
  ```

* 为抽象类 和 抽象方法

* 定义了抽象方法必须声明为抽象类

* 抽象方法只有签名没有方法体

* 抽象类也就是不完整的设计图，交由子类继承并完成

* 子类必须重写完抽象父类的全部抽象方法

* 不能创建对象

* final与abstract为互斥关系

* 模板方法模式：定义抽象类，再在类中定义通用且确定的部分代码为模板方法，其他不同的不确定的定义为抽象方法交由继承的子类自定义，抽象方法会被模板方法在方法体中某处被调用，给模板方法加上final，使其不会被子类重写，更安全优雅

  ```java
  public abstract class Student{
      public final void write() {
          ...
          this.writeMain();
          ...
      }
      
      public abstract String writeMain();
  }
  ```







## . Java的集合

* 概述：大小不固定，可以动态变化，类型也不固定，适合元素个数不确定，且要增删的场景，还有许多API可以调用
* 