# 为什么重写equals后还要重写hashCode方法?

> 同时重写这两个方法时的场景是在应用HashSet集合时，如果存储到了内容相同的对象数据，我们需要去掉重复的



* 首先，HashSet的存储机制，是利用哈希算法。也就是**根据对象的哈希值**和默认创建的内置数组长度（默认16）**求余算出的值**（范围为0-15），来**确定当前这个对象应该放在内置数组的哪个位置**
* 那么**显然，如果有哈希值相同的对象，那么它们会存储到一个位置上**
* **这时候，会调用它们的equals方法**，默认比较这两个对象的地址，判断它们是否为同一个对象



回到正题

如果我们想要HashSet去重复时，希望内容一样的两个对象被当做重复对象，去掉重复，默认是办不到的。

* 因为，首先，对于哈希值，不同对象的哈希值默认是不一样的，极小概率哈希值会一样
* 也就是这两个内容一样的对象在进行哈希算法确定该存储的位置时，算出来的位置是不一样的
* 那么也就调用不了对应的equals方法比较内容是否一样了（当然首先你要重写了equals才能比较内容是否一致）
* 也就是要使HashSet调用equals方法的前提是，利用哈希算法算出来的位置上，已经有元素了才会调用



所以到底是为什么还需要重写hashCode呢？

* 要让HashSet调用我们重写后的equals方法，就需要元素根据哈希算法得出的位置是一样的，位置上有了元素，才会调用equals比较是否一样

* 要让位置一样，那么根据哈希算法，元素的哈希值与长度求余得出的值要一样

* 最方便的办法那就是使哈希值一样就保证了位置是一样的

* 位置一样后就会调用equals比较了

* 所以，为了使哈希值一样，我们就需要重写Object类默认提供的hashCode方法

  ```java
  public int hashCode() {
      return Object.hash(成员变量名列表);
  }
  //IDEA自动生成即可，会帮你写好变量列表
  ```

* 当两个对象成员变量内容一样时，根据这个重写后的hashCode方法，计算出来的哈希值是一样的

* 也就是，两个内容一样的对象，利用重写后的hashCode方法计算出来的哈希值是一样的

* 哈希值一样之后，存储位置也就是一样的

* 然后就会调用重写后的equals比较内容是否一样，一样则不会存入

* 从而去掉内容一样的对象



总的来说，不同对象的 hashCode 可能相同，但 hashCode 不同的对象一定不相等，所以使用 hashCode 可以起到快速初次判断对象是否相等的作用。hashCode 和 equals 两个方法是用来协同判断两个对象是否相等的，采用这种方式的原因是可以提高程序插入和查询的速度，如果在重写 equals 时，不重写 hashCode，就会导致在某些场景下，例如将两个相等的自定义对象存储在 Set 集合时，就会出现程序执行的异常，为了保证程序的正常执行，所以我们就需要在重写 equals 时，也一并重写 hashCode 方法才行。



所以，重写equals还要重写hashCode方法



> ©iWyh2