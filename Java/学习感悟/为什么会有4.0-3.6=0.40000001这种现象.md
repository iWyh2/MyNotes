# 为什么会有4.0-3.6=0.40000001的现象？

这种舍入误差的主要原因是：
**浮点数值采用二进制系统表示， 而在二进制系统中无法精确地表示分数 1/10**



这就好像十进制无法精确地表示分数 1/3—样。


浮点数值不适用于无法接受舍入误差的金融计算中。
例如，命令 System.out.println ( 2.0-1.1 ) 将打印出 0.8999999999999999, 而不是人们想象的 0.9。

为什么二进制无法精确表示1/10
其实跟数位表示法有关，比如十进制的情况下：
123，相当于（值*进制^位置，个位0，十位1，百位2）
同理：1/10由二进制表示小数的时候只能够表示能够用1/(2^n)

例如：
0.5能够表示，因为它可以表示成为 1/2
0.75也能够表示，因为它可以表示成为 1/2+1/2^2
0.875也能够表示，因为它可以表示成为 1/2+1/2^2+1/2^3
0.9375也能够表示，因为它可以表示成为 1/2+1/2^2+1/2^3+1/2^4
**但是0.1不能够精确表示，因为它不能表示成为1/(2^n)的和的形式**

如果在数值计算中不允许有任何舍入误差， 就应该使用 BigDecimal类。

扩展：

大数值

如果基本的整数和浮点数精度不能够满足需求， 那么可以使用java.math 包中的两个 很有用的类：Biglnteger 和 BigDecimal 这两个类**可以处理包含任意长度数字序列的数值**。 Biglnteger类实现了**任意精度的整数运算**， BigDecimal 实现了**任意精度的浮点数运算**。

使用静态的 valueOf方法可以将普通的数值转换为大数值：

```java
Biglnteger a = Biglnteger.valueOf(100); 
```

遗憾的是，不能使用人们熟悉的算术运算符（如：+ 和 *) 处理大数值。
而需要使用大数 值类中的 add 和 multiply 方法。

```java
Biglnteger c = a.add(b); // c = a + b 
Biglnteger d = c.nultipiy(b.add(Biglnteger.valueOf(2))); // d = c * (b + 2)
```

注释：

与 C++ 不同， Java 没有提供运算符重载功能。

程序员无法重定义 + 和 * 运算 符

使其应用于BigInteger 类的 add 和 multiply 运算。

Java 语言的设计者确实为字符串的连接重载了 + 运算符，但没有重载其他的运算符，也没有给 Java 程序员在自己的类中重载运算符的机会